求第k大：
#include<iostream>
#include<algorithm>
using namespace std;

int a[1000], n, k;
int part(int ileft, int iright);
int search(int n, int k);
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	cin >> k;
	cout << search(n, k);
	return 0;
}

int part(int ileft, int iright) {
	if (ileft == iright)
		return ileft;
	int i = ileft + 1, j = iright,pivot = a[ileft];
	while (i <= j){
		while (i <= j && a[i] < pivot)
		i++;
	while (i <= j && a[i] > pivot)
		j--;
	if (i < j) {
		swap(a[i], a[j]);
		i++;
		j--;
	}
		}
	swap(a[ileft], a[j]);
	return j;
}

int search(int n, int k) {
	random_shuffle(a + 1, a + n + 1);
	int t = n - k + 1;
	int ileft = 1, iright = n;
	int mid;
	while (ileft <= iright) {
		mid = part(ileft, iright);
		if (mid == t) break;
		else if (t < mid) iright = mid - 1;
		else ileft = mid + 1;

	}
	return a[mid];
}


求两个链表的交集
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>
#define MAX 100

typedef struct LNode {
	int data;
	struct LNode* next;
}LNode, * LinkList;

int InitList(LinkList& L) {
	L = new LNode;
	L->next = NULL;
	return 1;
}

void TraveList(LinkList L) {
	struct LNode* p;
	p = L->next;
	while (p) {
		printf("%d ", p->data);
		p = p->next;
	}
	printf("\n");
}

int ListLength(LinkList& L) {
	int length = 0;
	struct LNode* p;
	p = L->next;
	while (p) {
		++length;
		p = p->next;
	}
	return length;
}

void CreateList(LinkList& L, int n) {
	L = new LNode;
	L->next = NULL;
	struct LNode* r;
	r = L;
	for (int i = 0; i < n; i++) {
		printf("请输入第%d个元素的值:", i + 1);
		struct LNode* s;
		s = new LNode;
		scanf("%d", &s->data);
		s->next = NULL;
		r->next = s;
		r = s;
	}
}

/*
算法思想：
假设两个表分别是L1和L2，表的元素递增排列；需要3个指针，pa，pb，pc.
指针的初始值是pa指向L1的第一个结点，pb指向L2的第一个结点，pc指向新表L3的头结点；
初始时，L3指向L1的头结点。
当pa和pb的指向都非空时，比较pa和pb所指向的元素的值，当pa->data<pb->data时，指针pa后移，pb不变；
当pa->data>pb->data时，pb指针后移，pa不变；
当pa->data==pb->data时，让指针pc指向pa,之后pa和pb都后移.
*/
void Intersection(LinkList& L1, LinkList& L2, LinkList& L3) {
	struct LNode* pa, * pb, * pc;
	pa = L1->next;
	pb = L2->next;
	L3 = L1;
	pc = L3;
	//L3->next=NULL;
	while (pa && pb) {
		struct LNode* q;
		if (pa->data < pb->data) {
			pa = pa->next;
		}
		else if (pa->data > pb->data) {
			pb = pb->next;
		}
		else if (pa->data == pb->data) {
			pc->next = pa;
			pc = pa;
			pa = pa->next;
			pb = pb->next;
		}
	}
}
int main() {
	LinkList L1, L2, L3;

	if (InitList(L1)) {
		printf("表L1初始化成功!\n");
	}
	else {
		printf("表L1初始化失败!\n");
	}

	if (InitList(L2)) {
		printf("表L2初始化成功!\n");
	}
	else {
		printf("表L2初始化失败!\n");
	}

	if (InitList(L3)) {
		printf("表L3初始化成功!\n");
	}
	else {
		printf("表L3初始化失败!\n");
	}

	printf("请输入L1的长度:");
	int n1;
	scanf("%d", &n1);
	CreateList(L1, n1);
	printf("L1的长度:%d\n", ListLength(L1));
	TraveList(L1);

	printf("请输入L2的长度:");
	int n2;
	scanf("%d", &n2);
	CreateList(L2, n2);
	TraveList(L2);

	Intersection(L1, L2, L3);
	printf("输出交集:\n");
	TraveList(L1);
}

两个多项式相加
#include<iostream>
using namespace std;

typedef struct Polynimial
{
	double coef;				//系数
	int exp;					//指数
	struct Polynimial* next;
}Polynimial, * PolynimialList;

/*创建一元多项式*/
void CreatePolynimial(PolynimialList& L)
{
	double coef;
	int exp;
	L = new Polynimial;		//创建头节点，其next域置为NULL
	L->next = NULL;
	Polynimial* p;
	Polynimial* r = L;		//r始终指向尾结点，初始时指向头结点
	cout << "请依次输入多项式的系数与指数（输入指数为0表示结束）：" << endl;
	cin >> coef >> exp;
	while (coef != 0)			//循环建立数据结点p
	{
		p = (Polynimial*)new Polynimial;
		p->coef = coef;
		p->exp = exp;
		r->next = p;		//利用尾插法，插入结点
		r = p;
		cin >> coef >> exp;
	}
	r->next = NULL;			//尾结点的next域置为NULL
}

/*删除一元多项式的某一项*/
void DestroyPolynomial(PolynimialList& L)
{
	Polynimial* pre = L, * p = L->next;
	while (p != NULL)
	{
		delete pre;
		pre = p;
		p = p->next;
	}
	delete pre;
}

/*合并多项式*/
void CombinePolynomial(PolynimialList& P, PolynimialList& Q)
{
	Polynimial* p, * q, * pre, * temp;
	p = P->next;
	q = Q->next;
	pre = P;
	temp = NULL;
	while (p != NULL && q != NULL)	//扫描p与q，当任意一个扫描完时，跳出循环
	{
		if (p->exp < q->exp)
		{
			pre = p;		  //pre与p后移
			p = p->next;
		}
		else if (p->exp > q->exp)
		{
			temp = q->next;	  //保存q的后继结点的地址	
			q->next = p;      //将q结点插入p结点之前，pre之后
			pre->next = q;
			pre = pre->next;  //pre后移
			q = temp;         //q后移
		}
		else
		{
			p->coef = p->coef + q->coef;
			if (p->coef == 0)
			{
				temp = p;		//删除结点p，p后移
				p = p->next;
				pre->next = p;
				free(temp);
			}
			else
			{
				pre = p;		//pre与p后移
				p = p->next;
			}
			temp = q;			//删除结点q，q后移
			q = q->next;
			free(temp);
		}
	}
	if (q != NULL)				//如果p扫描完(p=null,pre指向最后一个结点)，q未扫描完,
	{
		pre->next = q;
	}
}

/*输出一元多项式*/
void PrintPolynimial(PolynimialList& L)
{
	Polynimial* p = L->next;
	if (p == NULL)
	{
		cout << "该多项式为空项！" << endl;
	}
	cout << "多项式为 ：";
	while (p != NULL)
	{

		if (p->exp != 0)	cout << p->coef << "*x^" << p->exp;
		else                cout << p->coef;
		if (p->next != NULL && p->next->coef > 0)
		{
			cout << " + ";
		}
		p = p->next;
	}
}

int main()
{
	PolynimialList P = NULL, Q = NULL;		//创建多项式P(x)与Q(x)
	cout << "1.构造多项式P(x)" << endl;
	CreatePolynimial(P);
	PrintPolynimial(P);
	cout << "\n\n2.构造多项式Q(x)" << endl;
	CreatePolynimial(Q);
	PrintPolynimial(Q);
	cout << "\n\n3.多项式求和" << endl;
	CombinePolynomial(P, Q);				//合并多项式
	PrintPolynimial(P);						//输出合并后的多项式
	DestroyPolynomial(P);					//销毁链表
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
实验四：
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define MAXSIZE 100
#define ERROR 0
#define OK 1
typedef int SElemType;
typedef int Status;

typedef struct Queue {
	SElemType data[MAXSIZE];
	int front;
	int rear;
} Queue;

//初始化队列 
void InitQueue(Queue* q) {
	q->data[0] = 0;
	q->front = 0;
	q->rear = 0;
}

//入队
Status EnQueue(Queue* q, SElemType num) {
	if (q->rear >= MAXSIZE - 1) {
		return ERROR;
	}
	q->data[q->rear] = num;
	q->rear++;
	return OK;
}

//出队
Status DeQueue(Queue* q, SElemType* num) {
	if (q->front >= q->rear) {
		return ERROR;
	}
	*num = q->data[q->front];
	q->front++;
	return OK;
}

//获取头元素 
Status GetHead(Queue* q, SElemType* num) {
	if (q->front >= q->rear) {
		return ERROR;
	}
	*num = q->data[q->front];
	return OK;
}

//获取尾元素 
Status GetRear(Queue* q, SElemType* num) {
	if (q->front >= q->rear) {
		return ERROR;
	}
	*num = q->data[q->rear - 1];
	return OK;
}

int main() {
	Queue H1;
	InitQueue(&H1);
	Queue H2;
	InitQueue(&H2);
	Queue H3;
	InitQueue(&H3);
	Queue* QArray[] = { &H1, &H2, &H3 };//指向结构体的指针数组,将H1,H2,H3放入数组 
	printf("请输入火车车厢,输入0停止输入\n");
	while (true) {//元素全部入队进H3 
		int num;
		scanf("%d", &num);
		if (num == 0) {
			break;
		}
		EnQueue(&H3, num);
	}
	//	int num;
	//	GetRear(&H3, &num);
	//	printf("%d\n", num);

	int nowOut = 1;//火车车厢排序的关键 
	printf("\n出队序列为:");
	//遍历H3队列 
	while (H3.front < H3.rear || H1.front < H1.rear || H2.front < H2.rear) {
		int flag = 0;
		int num;
		GetHead(&H3, &num);
		//如果当前遍历元素等于nowOut就H3对头元素出队 
		if (num == nowOut) {
			DeQueue(&H3, &num);
			printf("%d", num);
			nowOut++;
			flag = 1;
		}
		else {
			//否则去寻找H1和H2对头元素是否等于nowOut,等于就出队 
			for (int i = 0; i < 2; i++) {
				GetHead(QArray[i], &num);
				if (num == nowOut) {
					DeQueue(QArray[i], &num);
					printf("%d", num);
					nowOut++;
					flag = 1;
				}
			}
		}
		/*
		如果H1,H2,H3的对头都没有等于nowOut的元素,
		那么就将该元素入队至H1或H2,条件是小于队尾元素
		*/
		if (flag == 0) {
			int container;
			for (int i = 0; i < 2; i++) {
				GetHead(&H3, &num);
				GetRear(QArray[i], &container);
				if (num > container || QArray[i]->rear == 0) {
					DeQueue(&H3, &num);
					EnQueue(QArray[i], num);
					break;
				}
			}
		}

	}
	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
